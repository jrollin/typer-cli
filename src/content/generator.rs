use super::bigram_generator::BigramGenerator;
use super::code_generator::CodeSymbolGenerator;
use super::common_word_generator::CommonWordGenerator;
use super::lesson::{Lesson, LessonType, RowLevel};
use super::trigram_generator::TrigramGenerator;
use crate::keyboard::{AzertyLayout, RowType};

/// Trait pour générer du contenu de leçon
pub trait ContentGenerator {
    fn generate(&self, length: usize) -> String;
}

impl ContentGenerator for Lesson {
    fn generate(&self, length: usize) -> String {
        match &self.lesson_type {
            LessonType::Bigram {
                bigram_type,
                language,
                level,
            } => {
                let generator = BigramGenerator::new(*bigram_type, *language);
                generator.generate(*level, length)
            }
            LessonType::Trigram { language, level } => {
                let generator = TrigramGenerator::new(*language);
                generator.generate(*level, length)
            }
            LessonType::CommonWords { language, level } => {
                let generator = CommonWordGenerator::new(*language);
                generator.generate(*level, length)
            }
            LessonType::CodeSymbols { language, level } => {
                let generator = CodeSymbolGenerator::new(*language);
                generator.generate(*level, length)
            }
            LessonType::Adaptive => {
                // Adaptive content generation is handled in app.rs
                // This should not be called directly
                "Adaptive mode content is generated by AdaptiveLessonGenerator".to_string()
            }
            LessonType::FingerPair {
                finger_pair,
                level,
                with_shift,
            } => {
                use crate::content::finger_generator::{
                    generate_finger_drills, get_finger_pair_keys,
                };
                use crate::keyboard::azerty::AzertyLayout;

                let layout = AzertyLayout::new();
                let keys = get_finger_pair_keys(&layout, *finger_pair, *level, *with_shift);
                generate_finger_drills(&keys, length, *with_shift)
            }
            LessonType::RowProgression { level, with_shift } => {
                use crate::content::finger_generator::generate_finger_drills;
                use crate::keyboard::azerty::AzertyLayout;

                let layout = AzertyLayout::new();
                let keys = get_keys_for_row_level(&layout, *level, *with_shift);
                generate_finger_drills(&keys, length, *with_shift)
            }
            LessonType::Custom { content } => {
                // Return content as-is, truncated to requested length
                // Preserves formatting: line breaks, spacing, indentation
                content.chars().take(length).collect()
            }
        }
    }
}

/// Get keys for row progression lessons (all fingers, progressive rows)
pub fn get_keys_for_row_level(
    layout: &AzertyLayout,
    level: RowLevel,
    with_shift: bool,
) -> Vec<char> {
    let row_types = match level {
        RowLevel::Level1 => vec![RowType::Home],
        RowLevel::Level2 => vec![RowType::Home, RowType::Top],
        RowLevel::Level3 => vec![RowType::Home, RowType::Top, RowType::Bottom],
        RowLevel::Level4 => vec![
            RowType::Home,
            RowType::Top,
            RowType::Bottom,
            RowType::Number,
        ],
    };

    let mut keys = Vec::new();

    for row in &layout.rows {
        if row_types.contains(&row.row_type) {
            for key in &row.keys {
                // Skip placeholder keys (null characters, newlines, modifier symbols)
                if key.base == '\0' || key.base == '\n' {
                    continue;
                }

                // Add base character
                keys.push(key.base);

                // Add shift variant if requested
                if with_shift {
                    if let Some(shifted) = key.shift_variant {
                        // Avoid adding duplicates
                        if shifted != key.base && !keys.contains(&shifted) {
                            keys.push(shifted);
                        }
                    }
                }
            }
        }
    }

    // Remove duplicates and sort
    keys.sort();
    keys.dedup();

    keys
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_keys_for_row_level_progression() {
        let layout = AzertyLayout::new();

        // Level 1: Home row only
        let keys_l1 = get_keys_for_row_level(&layout, RowLevel::Level1, false);
        assert!(!keys_l1.is_empty());
        assert!(keys_l1.contains(&'q'));
        assert!(keys_l1.contains(&'s'));
        assert!(keys_l1.contains(&'d'));

        // Level 2: Home + Top (should be superset of Level 1)
        let keys_l2 = get_keys_for_row_level(&layout, RowLevel::Level2, false);
        assert!(keys_l2.len() > keys_l1.len());
        assert!(keys_l2.contains(&'a')); // Top row
        assert!(keys_l2.contains(&'z')); // Top row
        for key in &keys_l1 {
            assert!(keys_l2.contains(key)); // Level 1 keys should be in Level 2
        }

        // Level 3: Home + Top + Bottom
        let keys_l3 = get_keys_for_row_level(&layout, RowLevel::Level3, false);
        assert!(keys_l3.len() > keys_l2.len());
        assert!(keys_l3.contains(&'w')); // Bottom row
        assert!(keys_l3.contains(&'x')); // Bottom row

        // Level 4: All rows including Numbers
        let keys_l4 = get_keys_for_row_level(&layout, RowLevel::Level4, false);
        assert!(keys_l4.len() > keys_l3.len());
        assert!(keys_l4.contains(&'&')); // Number row
        assert!(keys_l4.contains(&'é')); // Number row
    }

    #[test]
    fn test_get_keys_for_row_level_with_shift() {
        let layout = AzertyLayout::new();

        // Without shift
        let keys_no_shift = get_keys_for_row_level(&layout, RowLevel::Level1, false);

        // With shift
        let keys_with_shift = get_keys_for_row_level(&layout, RowLevel::Level1, true);

        // With shift should have more keys (includes uppercase/shifted variants)
        assert!(keys_with_shift.len() > keys_no_shift.len());
    }

    #[test]
    fn test_row_progression_content_generation() {
        let lessons = Lesson::row_progression_lessons();

        // Test Level 1 lesson
        let content = lessons[0].generate(50);
        assert!(!content.is_empty());
        assert!(content.len() <= 50);

        // Test Level 4 lesson
        let content_l4 = lessons[6].generate(100);
        assert!(!content_l4.is_empty());
        assert!(content_l4.len() <= 100);
    }
}
